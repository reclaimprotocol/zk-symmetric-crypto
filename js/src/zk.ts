import { concatenateUint8Arrays } from '@reclaimprotocol/tls'
import { CONFIG } from './config.ts'
import type { EncryptionAlgorithm, GenerateProofOpts, GenerateWitnessOpts, GetPublicSignalsOpts, Proof, VerifyProofOpts, ZKProofInput, ZKProofPublicSignals } from './types.ts'
import { getBlockSizeBytes, getCounterForByteOffset } from './utils.ts'

/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 */
export async function generateProof(opts: GenerateProofOpts): Promise<Proof> {
	const { algorithm, operator, logger } = opts
	const { witness, plaintextArray } = await generateZkWitness(opts)
	let wtnsSerialised: Uint8Array
	if('mask' in opts) {
		wtnsSerialised = await operator.generateWitness({
			...witness,
			toprf: opts.toprf,
			mask: opts.mask,
		})
	} else {
		// @ts-expect-error
		wtnsSerialised = await operator.generateWitness(witness)
	}

	const { proof } = await operator.groth16Prove(wtnsSerialised, logger)

	return { algorithm, proofData: proof, plaintext: plaintextArray }
}

/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
export async function verifyProof(opts: VerifyProofOpts): Promise<void> {
	const publicSignals = await getPublicSignals({
		algorithm: opts.proof.algorithm,
		plaintext: opts.proof.plaintext,
		publicInput: opts.publicInput,
	})

	const { proof: { proofData }, operator, logger } = opts
	let verified: boolean
	if('toprf' in opts) {
		verified = await operator.groth16Verify(
			{ ...publicSignals, toprf: opts.toprf },
			proofData,
			logger
		)
	} else {
		// serialise to array of numbers for the ZK circuit
		verified = await operator.groth16Verify(
			// @ts-expect-error
			publicSignals, proofData, logger
		)
	}

	if(!verified) {
		throw new Error('invalid proof')
	}
}

/**
 * Generate a ZK witness for the symmetric encryption circuit.
 * This witness can then be used to generate a ZK proof,
 * using the operator's groth16Prove function.
 */
export async function generateZkWitness({
	algorithm,
	privateInput: { key },
	publicInput,
}: GenerateWitnessOpts,
) {
	const { keySizeBytes } = CONFIG[algorithm]
	if(key.length !== keySizeBytes) {
		throw new Error(`key must be ${keySizeBytes} bytes`)
	}

	const witness: ZKProofInput = {
		key,
		...await getPublicSignals({ publicInput, algorithm, key })
	}

	return { witness, plaintextArray: witness.out }
}

export async function getPublicSignals(
	{ publicInput, algorithm, ...opts }: GetPublicSignalsOpts
) {
	publicInput = Array.isArray(publicInput) ? publicInput : [publicInput]
	if(!publicInput.length) {
		throw new Error('at least one public input is required')
	}

	const { ivSizeBytes } = CONFIG[algorithm]
	const ciphertextBlocks: Uint8Array[] = []
	const plaintextBlocks: Uint8Array[] = []
	const noncesAndCounters: { nonce: Uint8Array, counter: number }[] = []
	const blockSize = getBlockSizeBytes(algorithm)

	for(const { ciphertext, iv, offsetBytes = 0 } of publicInput) {
		if(iv.length !== ivSizeBytes) {
			throw new Error(`iv must be ${ivSizeBytes} bytes`)
		}

		const startCounter = getCounterForByteOffset(algorithm, offsetBytes)
		const ciphertextArray
			= padCiphertextToChunkSize(algorithm, ciphertext)

		const blocksInCiphertext = Math.ceil(ciphertextArray.length / blockSize)
		for(let i = 0; i < blocksInCiphertext; i++) {
			noncesAndCounters.push({ nonce: iv, counter: startCounter + i })
		}

		ciphertextBlocks.push(ciphertextArray)
		if('key' in opts) {
			const plaintextArray = await decryptCiphertext({
				algorithm,
				key: opts.key,
				iv,
				startOffset: offsetBytes,
				ciphertext: ciphertextArray,
			})
			plaintextBlocks.push(plaintextArray)
		}
	}

	const pubSigs: ZKProofPublicSignals = {
		noncesAndCounters,
		in: concatenateUint8Arrays(ciphertextBlocks),
		out: 'plaintext' in opts
			? opts.plaintext
			: concatenateUint8Arrays(plaintextBlocks),
	}

	const expSize = getExpectedChunkSizeBytes(algorithm)
	if(pubSigs.in.length !== getExpectedChunkSizeBytes(algorithm)) {
		throw new Error(
			`Ciphertext must be exactly ${expSize}b, got ${pubSigs.in.length}b`
		)
	}

	return pubSigs
}

function padCiphertextToChunkSize(
	alg: EncryptionAlgorithm,
	ciphertext: Uint8Array
) {
	const { chunkSize, bitsPerWord } = CONFIG[alg]

	const expectedSizeBytes = (chunkSize * bitsPerWord) / 8
	if(ciphertext.length > expectedSizeBytes) {
		throw new Error(`ciphertext must be <= ${expectedSizeBytes}b`)
	}

	if(ciphertext.length < expectedSizeBytes) {
		const arr = new Uint8Array(expectedSizeBytes)
		arr.set(ciphertext)

		ciphertext = arr
	}

	return ciphertext
}

function getExpectedChunkSizeBytes(alg: EncryptionAlgorithm) {
	const { blocksPerChunk } = CONFIG[alg]
	return getBlockSizeBytes(alg) * blocksPerChunk
}

type DecryptCiphertextOpts = {
	algorithm: EncryptionAlgorithm
	key: Uint8Array
	iv: Uint8Array
	startOffset: number
	ciphertext: Uint8Array
}

async function decryptCiphertext({
	algorithm,
	key,
	iv,
	startOffset,
	ciphertext,
}: DecryptCiphertextOpts) {
	const { encrypt } = CONFIG[algorithm]
	// fake the start of the ciphertext (it's irrelevant)
	const inp = new Uint8Array(startOffset + ciphertext.length)
	inp.set(ciphertext, startOffset)

	const out = await encrypt({ key, iv, in: inp })
	return out.slice(startOffset)
}