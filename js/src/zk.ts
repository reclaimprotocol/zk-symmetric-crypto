import { CONFIG } from './config'
import { EncryptionAlgorithm, GenerateProofOpts, GenerateWitnessOpts, GetPublicSignalsOpts, isBarretenbergOperator, OPRFOperator, Proof, VerifyProofOpts, ZKOperator, ZKProofInput, ZKProofPublicSignals, ZKProofPublicSignalsOPRF } from './types'
import { getCounterForByteOffset } from './utils'

/**
 * Generate ZK proof for CHACHA20-CTR encryption.
 * Circuit proves that the ciphertext is a
 * valid encryption of the given plaintext.
 * The plaintext can be partially redacted.
 */
export async function generateProof(opts: GenerateProofOpts): Promise<Proof> {
	const { algorithm, operator, logger } = opts
	const { witness, plaintextArray } = await generateZkWitness(opts)
	let wtnsSerialised: Uint8Array
	if('mask' in opts) {
		wtnsSerialised = await operator.generateWitness({
			...witness,
			toprf: opts.toprf,
			mask: opts.mask,
		})
	} else {
		// @ts-expect-error
		wtnsSerialised = await operator.generateWitness(witness)
	}

	const proveFn = isBarretenbergOperator(operator)
		? operator.ultrahonkProve
		: (operator).groth16Prove

	const proof = await proveFn(wtnsSerialised, logger)


	return { algorithm, proofData: proof.proof, plaintext: plaintextArray }
}

/**
 * Verify a ZK proof for CHACHA20-CTR encryption.
 *
 * @param proofs JSON proof generated by "generateProof"
 * @param publicInput
 * @param zkey
 */
export async function verifyProof(opts: VerifyProofOpts): Promise<void> {
	const publicSignals = getPublicSignals(opts)

	const { proof: { proofData }, operator, logger } = opts
	let verified: boolean

	if(isBarretenbergOperator(operator)) {
		verified = await operator.ultrahonkVerify(
			publicSignals,
			proofData,
			logger
		)
	} else {
		if('toprf' in opts) {
			const publicSignalsWithToprf: ZKProofPublicSignalsOPRF = {
				...publicSignals,
				toprf: opts.toprf
			}
			verified = await (operator as OPRFOperator).groth16Verify(
				publicSignalsWithToprf,
				proofData,
				logger
			)
		} else {
			verified = await (operator as ZKOperator).groth16Verify(
				publicSignals,
				proofData,
				logger
			)
		}
	}

	if(!verified) {
		throw new Error('invalid proof')
	}
}

/**
 * Generate a ZK witness for the symmetric encryption circuit.
 * This witness can then be used to generate a ZK proof,
 * using the operator's groth16Prove function.
 */
export async function generateZkWitness({
	algorithm,
	privateInput: { key },
	publicInput: { ciphertext, iv, offsetBytes = 0 },
}: GenerateWitnessOpts,
) {
	const {
		keySizeBytes,
		ivSizeBytes,
	} = CONFIG[algorithm]
	if(key.length !== keySizeBytes) {
		throw new Error(`key must be ${keySizeBytes} bytes`)
	}

	if(iv.length !== ivSizeBytes) {
		throw new Error(`iv must be ${ivSizeBytes} bytes`)
	}

	const startCounter = getCounterForByteOffset(algorithm, offsetBytes)
	const ciphertextArray = padCiphertextToChunkSize(
		algorithm,
		ciphertext,
	)
	const plaintextArray = await decryptCiphertext({
		algorithm,
		key,
		iv,
		startOffset: offsetBytes,
		ciphertext: ciphertextArray,
	})

	const witness: ZKProofInput = {
		key,
		nonce: iv,
		counter: startCounter,
		in: ciphertextArray,
		out: plaintextArray,
	}

	return { witness, plaintextArray }
}

export function getPublicSignals(
	{
		proof: { algorithm, plaintext },
		publicInput: { ciphertext, iv, offsetBytes = 0 },
	}: GetPublicSignalsOpts
): ZKProofPublicSignals {
	const startCounter = getCounterForByteOffset(algorithm, offsetBytes)
	const ciphertextArray = padCiphertextToChunkSize(
		algorithm,
		ciphertext
	)

	if(ciphertextArray.length !== plaintext.length) {
		throw new Error('ciphertext and plaintext must be the same length')
	}

	return {
		nonce: iv,
		counter: startCounter,
		in: ciphertextArray,
		out: plaintext,
	}
}

function padCiphertextToChunkSize(
	alg: EncryptionAlgorithm,
	ciphertext: Uint8Array
) {
	const { chunkSize, bitsPerWord } = CONFIG[alg]

	const expectedSizeBytes = (chunkSize * bitsPerWord) / 8
	if(ciphertext.length > expectedSizeBytes) {
		throw new Error(`ciphertext must be <= ${expectedSizeBytes}b`)
	}

	if(ciphertext.length < expectedSizeBytes) {
		const arr = new Uint8Array(expectedSizeBytes).fill(0)
		arr.set(ciphertext)

		ciphertext = arr
	}

	return ciphertext
}

type DecryptCiphertextOpts = {
	algorithm: EncryptionAlgorithm
	key: Uint8Array
	iv: Uint8Array
	startOffset: number
	ciphertext: Uint8Array
}

async function decryptCiphertext({
	algorithm,
	key,
	iv,
	startOffset,
	ciphertext,
}: DecryptCiphertextOpts) {
	const { encrypt } = CONFIG[algorithm]
	// fake the start of the ciphertext (it's irrelevant)
	const inp = new Uint8Array(startOffset + ciphertext.length)
	inp.set(ciphertext, startOffset)

	const out = await encrypt({ key, iv, in: inp })
	return out.slice(startOffset)
}